# 애그리거트
복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있어야 한다.  
그 방법이 바로 애그리거트.  
![image](https://github.com/shmin7777/ddd-architecture/assets/67637716/2a0fb3bc-513a-4091-8f4b-b7d26ff8f279)  

![image](https://github.com/shmin7777/ddd-architecture/assets/67637716/0d5eb94a-f91c-42d7-b575-0fdc6e3580d2)  
위 두개의 그림은 동일한 모델이지만 애그리거트를 사용함으로써 모델 간의 개별 모델 수준과 상위 수준에서 모두 이해할 수 있다.  

애그리거트는 복잡한 도메인을 단순한 구조로 만들어주고, 도메인 기능을 확장하고 변경하는데 필요한 노력도 줄어든다.  
애그리거트는 관련된 모델을 하나로 모았기 떄문에 한 애그리거트가 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.  

애그리거트는 경계를 갖는다.  
한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.  
각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.  
주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하는 등 자기 자신은 관리하지만,  
주문 애그리거트에서 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지는 않는다.  
<br>  
경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.  
도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.  
예들 들어 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 한 애그리거트에 속한다.  
<br>  
A가 B를 갖는다로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽다.  
주문의 경우 Order가 ShippingInfo와 ORderer를 가지므로 타당해 보일 수 있지만 반드시 A와 B가 한 애그리거트에 속한다는 것은 아니다.  

좋은 예는 상품과 리뷰이다.  
상품이 리뷰를 갖는다라고 생각할 수 있지만 상품과 리뷰는 함께 생성되지도 않고, 함께 변경되지도 않는다.  
게다가 상품을 변경하는 주체가 상품 담당자라면 리뷰를 생성하고 변경하는 주체는 고객이다.  

# 애그리거트 루트
