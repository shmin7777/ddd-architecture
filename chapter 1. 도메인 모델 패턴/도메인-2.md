# 도메인
## 도메인 모델 도출
도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것.  
주문 도메인과 관련된 몇 가지 요구사항을 보자.  
1. 최소 한 종류 이상의 상품을 주문해야 한다.
2. 한 상품을 한 개 이상 주문할 수 있다.
3. 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
4. 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
5. 주문할 때 배송지 정보를 반드시 지정해야 한다.
6. 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
7. 출고를 하면 배송지를 변경할 수 없다.
8. 출고 전에 주문을 취소할 수 있다.
9. 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.

아직 상세 구현까지 할 수 있는 수준은 아니지만 Order에 관련 메서드를 추가할 수 있다.  
```
class Order {
    fun changeShipped() {}
    fun changeShippingInfo(newShippingInfo: ShippingInfo){}
    fun cancel(){}
    fun completePayment(){}
}
```

2, 4 번 요구사항에 따르면 주문항목을 표현하는 OrderLine은 적어도 주문할 상품, 상품의 가격, 구매 개수를 포함해야한다.  
추가로 각 구매 항목의 구매 가격도 제공해야 한다.  

```
class OrderLine(
    private val product: Product,
    private val price: Int,
    private val quantity: Int,
    private val amounts: Int
) {
    fun calculateAmounts() = price * quantity
    
    fun getAmounts(): Int {}
}
```
orderLine은 한 상품(product)를 얼마에 몇 개 살지를 담고 있고 구매 가격을 구하는 로직을 구현하고 있다.  

1, 3번 요구사항은 Order와 OrderLine의 관계를 보여준다.  
한 종류 이상의 상품을 주문할 수 있으므로 Order는 최소 한 개 이상의 OrderLine을 포함해야한다.  
또한 총 주문 금액은 OrderLine에서 구할 수 있다.  
두 요구사항은 Order에 다음과 같이 구현할 수 있다.  
```
class Order(


) {
    private var orderLines: List<OrderLine> = listOf()
    private lateinit var totalAmounts: Money

    private fun setOrderLines(orderLines: List<OrderLine>) {
        verifyAtLeastOneOrMoreOrderLines(orderLines)
        this.orderLines = orderLines
    }

    private fun verifyAtLeastOneOrMoreOrderLines(orderLines: List<OrderLine>): Unit =
        orderLines.takeIf { it.isEmpty() }.run { throw IllegalArgumentException("no OrderLine") }


    private fun calculateTotalAmounts() {
        val sum = orderLines.map { it.getAmounts() }.sum()
        totalAmounts = Money(sum)
    }
```

주문과 관련된 요구사항에서 도메인 모델을 점진적으로 만들어 나갔다.  
일부는 구현수준까지 만들었고, 일부는 이름 정도만 결정했다.  

## 엔티티와 밸류
도출한 모델은 크게 엔티티와 밸류로 구분할 수 있다.  
<img width="445" alt="스크린샷 2024-02-09 오후 2 17 11" src="https://github.com/shmin7777/ddd-architecture/assets/67637716/940c63f4-32bd-4771-ab95-286aa7e36287">  

####  엔티티
엔티티의 가장 큰 특징은 식별자를 가진다.  
주문 도메인 모델에서 주문에 해당하는 클래스가 Order이므로 Order가 엔티티가 되며 주문 번호를 식별자로 갖는다.  
식벽자는 엔티티를 생성하고 속성을 바꾸고 삭제할 때까지 유지된다.  

엔티티의 식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단한다.  
따라서 equals와 hashcode를 구현할 때도 식별자만을 이용해서 구현한다.  

#### 엔티티의 식별자 생성
엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라진다.  
흔히 다음 중 한 가지 방식으로 생성한다.  
* 특정 규칙에 따라 생성
* UUID나 Nano ID와 같은 고유 식별자 생성기 사용
* 값을 직접 입력
* 인련번호 사용(시퀀스나 auto_increment)
* 현재 시간과 다른 값 조합

주의할 점은 식별자는 유일해야된다는 것.  

#### 밸류 타입
```
data class ShippingInfo (
    // 받는 사람
    private val receiverName: String,
    private val receiverPhoneNumber: String,
    // 주소
    private val shuppingAddress1: String,
    private val shuppingAddress2: String,
    private val shuppingZipcode: String,
)
```  
ShippingInfo 클래스는 받는 사람과 주소에 대한 데이터를 가지고 있다.  
receiverName와 receiverPhoneNumber는 서로 다른 두 데이터를 담고 있지만, 두 필드는 개념적으로 받는 사람을 의미한다.  
즉 두 필드는 실제로 하나의 개념을 표현한다.  
밸류 타입은 <b>개념적으로 완전한 하나를 표현할 때 사용한다.</b>

따라서 위 클래스는 다음과 같이 만들 수 있다.  
```
data class ShippingInfo (
    // 받는 사람
    private val receiver: Receiver,
    // 주소
    private val address: Address
){
    data class Receiver (
        private val name: String,
        private val phoneNumber: String
    )
    
    data class Address (
        private val adress1: String,
        private val adress2: String,
        private val zipcode: String,
    )
}
```




