# 리포지터리와 애그리거트
객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.  
Order와 OrderLine을 물리적으로 각각 별도의 DB테이블에 저장한다고 해서 Order와 OrderLine을 위한 리포지터리를 각각 만들지 않는다.  
Order가 애그리거트 루트고 OrderLine은 애그리거트에 속하는 구성요소이므로 Order을 위한 리포지터리만 존재한다.  
<br>  
어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.  
JPA를 사용하면 데이터베이스 관계형 모델에 객체 도메인 모델을 맞춰야 할 때도 있다.  
애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야한다.  
Order 애그리거트와 연관된 테이블이 세 개라면 Order 애그리거트를 저장할 때,  
애그리거트 루트와 매핑되는 테이블뿐만 아니라 모든 구성요소에 매핑된 테이블에 데이터를 저장해야한다.  
```
// 리포지터리에 애그리거트를 저장하면 애그리거트 전체를 영속화해야함
orderRepository.save(order)
```
동일하게 애그리거트를 구하는 find 메서드는 완전한 애그리거트를 제공해야 한다.  

# ID를 이용한 애그리거트 참조
애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다.  
![image](https://github.com/shmin7777/ddd-architecture/assets/67637716/61d575d6-b4b2-4a45-8c7f-59ee722a8ad9)  

애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다는 것.  
```
class Order {
  ...
  orderer.member.changeAddress(...)
}
```

두 번째 문제는 애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다는 것.  
JPA를 사용하면 참조한 객체를 지연(lazy), 즉시(eager)로딩의 두 가지 방법으로 로딩할 수 있다.  
다양한 경우의 수를 고려해서 연관 매핑과 로딩 전략을 결정해야 한다.  

세 번째 문제는 확장이다.  
트래픽이 몰리면서 하위 도메인마다 서로 다른 데이터 저장소를 사용하기도 한다.  
한 하위 도메인은 마리아DB를 사용하고 다른 하위 도메인은 몽고DB를 사용하는 식으로 말이다.  
이것은 더 이상 다른 애그리루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없다.  
<br>  
이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.  
![image](https://github.com/shmin7777/ddd-architecture/assets/67637716/6f881ff8-c991-4868-83d9-994e6421c530)  

ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.  
이는 애그리거트의 경계를 명확히 하고 애그리거트 간의 의존을 제거하므로 응집도를 높여준다.  

구현 복잡도도 낮아진다.  
다른 애그리거트를 직접 참조하지 않고, 참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 이용해서 로딩하면 된다.  
또한 애그리거트 별로 다른 구현 기술을 사용하는 것도 가능해진다.  
![image](https://github.com/shmin7777/ddd-architecture/assets/67637716/1dba16e8-891e-4926-96f3-3fbc6c09f579)  



## ID를 이용한 참조와 조회 성능
다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있다.  
예를 들어 주문 목록을 보여주려면 상품과 회원 애그리거트를 함꼐 읽어야 하는데,  
각 주문마다 상품과 회원 애그리거트를 읽어온다면, 주문마다 상품 정보를 읽어오는 쿼리를 실행하게 된다.  
=> N+1 문제가 발생하는데 이는 JPA 를 찾아보자

애그리거트마다 서로 다른 저장소를 사용한다면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.  
이떄는 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다.  
이 방법은 코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일 수 있다는 장점이 있다.  


